[{"name":"app.R","content":"\r\n# The INFEST app: insect feeding behavior statistics, the light version\r\n# shinylive::export(appdir = getwd(), destdir = \"docs\")\r\n# httpuv::runStaticServer(\"docs\")\r\n\r\nlibrary(shiny)\r\nlibrary(htmltools)\r\nlibrary(gamlss)\r\n\r\n# --------------------------------------------------\r\n# A function to process the insect feeding events from the EPG system\r\n\r\nepg <- function(filesIn, time_trim = NULL)\r\n{\r\n  files <- filesIn$name\r\n  nfiles <- length(files)\r\n  \r\n  # aux function for reading .ANA files\r\n  stylet_codes <- c(\"1\" = \"np\", \"2\" = \"C\", \"3\" = \"E1e\",\r\n                    \"4\" = \"E1\", \"5\" = \"E2\", \"6\" = \"F\",\r\n                    \"7\" = \"G\", \"8\" = \"pd\", \"9\" = \"II-2\",\r\n                    \"10\" = \"II-3\", \"11\" = \"w11\", \"12\" = \"w12\",\r\n                    \"99\" = \"T\")\r\n  read_ana <- function(f) {\r\n    d <- try(read.table(f, sep = \"\\t\", fileEncoding = \"UTF-16\"),\r\n             silent = TRUE)\r\n    if(inherits(d, \"try-error\")) d <- read.table(f, sep = \"\\t\",\r\n                                                 fileEncoding = \"UTF-8\")\r\n    d$V1 <- stylet_codes[as.character(d$V1)] # waveform\r\n    d$V2 <- as.double(gsub(\",\", \".\", d$V2))  # time\r\n    nr <- nrow(d)\r\n    dl <- lapply(1:nr, function(i) {\r\n      rbind(d$V1[i], d$V2[i])\r\n    })\r\n    unlist(dl)\r\n  }\r\n  \r\n  f_ext <- tools::file_ext( tolower(filesIn$datapath) )\r\n  ins  <- list()\r\n  for(i in 1:nfiles) {\r\n    ins[[i]] <- try(read_ana(filesIn$datapath[i]), silent = TRUE)\r\n    if(inherits(ins[[i]], \"try-error\")) {\r\n      ins[[i]] <- scan(filesIn$datapath[i],\r\n                       what = \"double\", sep = \",\", flush = TRUE, quiet = TRUE)\r\n      ins[[i]] <- gsub(\" \", \"\", ins[[i]], fixed = TRUE)\r\n    }\r\n    \r\n  }\r\n  names(ins) <- files\r\n  events <- sapply(ins, length)/2\r\n  \r\n  check <- (2*events) %% 2 != 0  # is odd = maybe missing lines\r\n  o <- which(check == TRUE)\r\n  if (any(check == TRUE)) {\r\n    ins[o] <- NULL\r\n    showNotification(paste(\" Error (please check line labels) in file(s):\",\r\n                           paste(files[o], collapse = \", \")),\r\n                     type = \"error\", duration = 10)\r\n  }\r\n  \r\n  fcheck2 <- function(x) {\r\n    aux <- seq.int(1, length(x), by = 1)\r\n    w <- x[aux %% 2 != 0]\r\n    n <- length(w)\r\n    any(w[-n] == w[-1])\r\n  }\r\n  check2 <- sapply(ins, fcheck2)\r\n  o2 <- which(check2 == TRUE)\r\n  if (any(check2 == TRUE)) {\r\n    showNotification(paste(\"The following file(s) seem(s) to have labels consecutively repeated :\",\r\n                           paste(files[o2], collapse = \", \")),\r\n                     type = \"warning\", duration = 10)\r\n  }\r\n  \r\n  # time trim (optional)\r\n  if(!is.null(time_trim)) {\r\n    ins <- lapply(ins, function(x) {\r\n      time_rec <- as.double(x)\r\n      o <- which(time_rec >= time_trim[1] & time_rec <= time_trim[2])\r\n      if(length(o) < 2) {\r\n        showNotification(\" Time interval is too short! \",\r\n                         type = \"error\", duration = 5)\r\n      }\r\n      w <- seq.int(min(o)-1, max(o), by = 1)\r\n      x[w]\r\n    })\r\n  }\r\n  \r\n  # aux function to get odd indexes from elements of ins list\r\n  fodd <- function(x) {\r\n    n <- length(x)\r\n    aux <- seq.int(1, n, by = 1)\r\n    y <- x[aux %% 2 != 0]\r\n    y\r\n  }\r\n  waves <- lapply(ins, fodd)\r\n  levels <- lapply(waves, unique)\r\n  lev <- unique(unlist(levels))\r\n  waves <- lapply(waves, factor, levels = lev)\r\n  table_func <- function(x) {\r\n    out <- table(x)\r\n    names(out) <- paste0(\"NWEi_\", names(out))\r\n    out\r\n  }\r\n  waveevents <- t(sapply(waves, table_func))   # output and export csv\r\n  \r\n  # aux function to compute the seq variables\r\n  countseq <- function(x) {\r\n    n <- length(x)\r\n    tabpair <- table(x[-n], x[-1], dnn = list(\"from\", \"to\"))\r\n    diag(tabpair) <- NA\r\n    dfpair <- data.frame(tabpair)\r\n    dfpair <- subset(dfpair, from != to)\r\n    pares <- paste0(dfpair$from, \"-\", dfpair$to)\r\n    count <- dfpair$Freq\r\n    names(count) <- pares\r\n    count\r\n  }\r\n  seqevents <- t(sapply(waves, countseq))   # output and export csv\r\n  \r\n  # get the sequential events as a 2-way table count for network graph\r\n  tableseq <- function(x) {\r\n    n <- length(x)\r\n    tabseq <- table(x[-n], x[-1], dnn = c(\"from\", \"to\"))\r\n    diag(tabseq) <- table(x)\r\n    tabseq\r\n  }\r\n  tabseq <- lapply(waves, tableseq)\r\n  sumtabseq <- Reduce(\"+\", tabseq)\r\n  \r\n  # transition matrix\r\n  countseq_m <- function(x) {\r\n    n <- length(x)\r\n    tabpair <- table(x[-n], x[-1], dnn = list(\"from\", \"to\"))\r\n    tabpair\r\n  }\r\n  tran_mats <- lapply(waves, countseq_m)\r\n  tran_mat <- Reduce(\"+\", tran_mats)\r\n  \r\n  # DURATION - aux funct using even and odd indexes at each element of the list\r\n  #nonprobe <- c(\"Z\", \"z\", \"np\", \"NP\", \"nP\", \"Np\")\r\n  w_nonprobe <- regexpr(c(\"np\", \"z\"), lev, ignore.case = TRUE) > 0\r\n  nonprobe <- lev[w_nonprobe]\r\n  probe_waves <- lev[!(lev %in% nonprobe)]\r\n  \r\n  evenodd <- function(x, arq) {\r\n    n <- length(x)\r\n    aux <- seq.int(1, n, by = 1)\r\n    waves <- factor(x[aux %% 2 != 0], levels = lev)\r\n    cumtimes <- as.numeric(x[aux %% 2 == 0])\r\n    if(arq == \"ana\") {\r\n      times <- diff(cumtimes)\r\n      n2 <- n/2\r\n      out <- tapply(times, waves[-n2], FUN = sum)\r\n    } else {\r\n      times <- c(cumtimes[1], diff(cumtimes))\r\n      out <- tapply(times, waves, FUN = sum)\r\n    }\r\n    names(out) <- paste0(\"WDi_\", names(out))\r\n    out\r\n  }\r\n  times <- t(sapply(ins, evenodd, arq = f_ext[1]))\r\n  times[is.na(times)] <- 0\r\n  \r\n  # duration per event\r\n  de <- times/waveevents\r\n  de[is.na(de)] <- 0\r\n  if(nrow(de) > 1 | !is.null(dim(de))) {\r\n    colnames(de) <- gsub(\"WDi\", \"WDEi\", colnames(de))\r\n  } else {\r\n    names(de) <- gsub(\"WDi\", \"WDEi\", names(de))\r\n  }\r\n  \r\n  # duration of first or second event 'W'\r\n  DurFS_func <- function(x, pos, arq) {\r\n    n <- length(x)\r\n    aux <- seq.int(1, n, by = 1)\r\n    waves <- factor(x[aux %% 2 != 0], levels = lev)\r\n    cumtimes <- as.numeric(x[aux %% 2 == 0])\r\n    if(arq == \"ana\") {\r\n      times <- diff(cumtimes)\r\n    } else {\r\n      times <- c(cumtimes[1], diff(cumtimes))\r\n    }\r\n    DurFSW <- sapply(lev, function(w) {\r\n      o <- which(waves %in% w)[pos]\r\n      times[o]\r\n    })\r\n    names(DurFSW) <- paste0(\"DurFrs_\", names(DurFSW))\r\n    DurFSW\r\n  }\r\n  DurFrsW <- t(sapply(ins, DurFS_func, pos = 1, arq = f_ext[1]))\r\n  DurFrsW[is.na(DurFrsW)] <- 0\r\n  \r\n  # number of events to first event W\r\n  NumEvFrsW_fun <- function(x) {\r\n    out <- sapply(probe_waves, function(w) {\r\n      r <- which(w == x)[1] - 1\r\n      names(r) <- paste0(\"NumEvFrs_\", w)\r\n      r\r\n    }, USE.NAMES = FALSE)\r\n    out\r\n  }\r\n  NumEvFrsW <- t(sapply(waves, NumEvFrsW_fun))\r\n  \r\n  final_data <- data.frame(times,\r\n                           waveevents,\r\n                           de,\r\n                           DurFrsW,\r\n                           NumEvFrsW)\r\n  # output\r\n  out <- list(duration = final_data,\r\n              seqevents = seqevents,\r\n              tabseqevents = sumtabseq,\r\n              transmatrix = tran_mat)\r\n  return(out)\r\n}\r\n\r\n# ----------------------------------------------------------\r\n# aux function\r\n\r\nf_rmse <<- function(model) {\r\n  res = model[[\"y\"]] - fitted(model)\r\n  sqrt(mean(res^2))\r\n}\r\n\r\nzerofams <<- c(\"NO\", \"PARETO2\", \"ZAGA\", \"ZAIG\",\r\n               \"PO\", \"NBII\", \"ZIP\", \"ZINBI\", \"PIG\")\r\n\r\n# ----------------------------------------------------------\r\n# aux function to automatically fit all models and gen. report\r\n\r\nlrt_func <- function(mod) {\r\n  l <- logLik(mod)\r\n  mod0 <- update(mod, formula = ~1, sigma.formula = ~1,\r\n                 family = mod$family[1])\r\n  l0 <- logLik(mod0)\r\n  X2 <- 2*c(l - l0)\r\n  grau <- attr(l, \"df\") - attr(l0, \"df\")\r\n  pval <- pchisq(X2, grau, lower = F)\r\n  if(inherits(mod, \"try-error\")) {\r\n    out <- list(X2 = NA, dfr = NA, pvalue = NA)\r\n  } else {\r\n    out <- list(X2 = X2, dfr = grau, pvalue = pval)\r\n  }\r\n  class(out) <- \"lrt_func\"\r\n  out\r\n}\r\n\r\nbest_family_full <- function(y, Group, conf = 0.95, adj = \"none\") {\r\n  fams <- c(\"NO\", \"EXP\", \"GA\", \"IGAMMA\", \"IG\",\r\n            \"WEI\", \"PARETO2\", \"ZAGA\", \"ZAIG\",\r\n            \"PO\", \"NBII\", \"ZIP\", \"ZINBI\", \"PIG\")\r\n  m1 <- m2 <- list()\r\n  nf <- length(fams)\r\n  d <- data.frame(y = y, Group = Group)\r\n  d <- d[complete.cases(d), ]\r\n  assign(\"ddd\", d, envir = .GlobalEnv)\r\n  for(i in 1:nf) {\r\n    dat <- get(\"ddd\", envir = .GlobalEnv)\r\n    m1[[i]] <- try(gamlss(dat$y ~ dat$Group, sigma.formula = ~1,\r\n                          family = fams[i],\r\n                          #data = get(\"ddd\", envir = .GlobalEnv),\r\n                          trace=FALSE),\r\n                   silent = TRUE)\r\n    m2[[i]] <- try(gamlss(dat$y ~ dat$Group, sigma.formula = ~Group,\r\n                          family = fams[i],\r\n                          #data = get(\"ddd\", envir = .GlobalEnv),\r\n                          trace=FALSE),\r\n                   silent = TRUE)\r\n  }\r\n  gams <- c(m1, m2)\r\n  aics <- sapply(gams, function(w) {\r\n    ifelse(inherits(w, \"try-error\"), NA, AIC(w))\r\n  })\r\n  o_aic <- which.min(aics)\r\n  if(length(o_aic) == 0) o_aic = 1\r\n  mod <- gams[[o_aic]]\r\n  if(!inherits(mod, \"try-error\")) {\r\n    mod$family <- gams[[o_aic]]$family\r\n    mod$call[4] <- mod$family[1]\r\n    lrt <- lrt_func(mod)\r\n    dfr <- mod$df.residual\r\n    aic <- mod$aic\r\n    rmse <- f_rmse(mod)\r\n  } else {\r\n    mod$family <- c(NA, NA)\r\n    mod$call[4] <- NA\r\n    lrt <- list(X2 = NA, dfr = NA, pvalue = NA)\r\n    dfr <- NA\r\n    aic <- NA\r\n    rmse <- NA\r\n  }\r\n  out <- list(dtf = d,\r\n              fit = mod,\r\n              lrt = lrt,\r\n              conf = conf,\r\n              adj = adj,\r\n              dfr = dfr,\r\n              family = mod$family,\r\n              aic = aic,\r\n              rmse = rmse)\r\n  class(out) <- \"infest\"\r\n  return(out)\r\n}\r\n\r\n\r\n# server ---------------------------------------------------\r\nserver <- function(input, output, session){\r\n  filesIn <- reactive({\r\n    validate(\r\n      need(input$files != \"\", \"...waiting for the input files\")\r\n    )\r\n    input$files\r\n  })\r\n  \r\n  observeEvent(input$showSidebar, {\r\n    shinyjs::show(id = \"Sidebar\")\r\n  })\r\n  observeEvent(input$hideSidebar, {\r\n    shinyjs::hide(id = \"Sidebar\")\r\n  })\r\n  \r\n  tab <- eventReactive(input$run, {\r\n    epg(filesIn(), time_trim = input$time_range * 60)\r\n  })\r\n  \r\n  # ------------------------------------- duration\r\n  dur <- reactive({\r\n    df <- tab()$duration\r\n    n <- nrow(df)\r\n    df <- data.frame(Group = as.integer(rep(1, n)), round(df, 2))\r\n    df\r\n  })\r\n  \r\n  output$duration <- rhandsontable::renderRHandsontable({\r\n    df_den <- data.frame(Group = dur()[, 1], dur()[, -1])\r\n    updateSelectInput(session, inputId = 'y', choices = names(df_den)[-1])\r\n    rhandsontable::rhandsontable(df_den, rowHeaderWidth=180)\r\n  })\r\n  mt <- reactive({\r\n    DF = rhandsontable::hot_to_r(input$duration)\r\n    if(!is.null(input$tab$changes$changes)) {\r\n      row.no <- unlist(input$tab$changes$changes)[1]\r\n      col.no <- unlist(input$tab$changes$changes)[2]\r\n      new.val <- unlist(input$tab$changes$changes)[4]\r\n    }\r\n    DF\r\n  })\r\n  \r\n  output$downloadData <- downloadHandler(\r\n    filename = function() {\r\n      \"infest_data.csv\"\r\n    },\r\n    content = function(file) {\r\n      grupos <- as.factor(mt()[, 1])\r\n      req(nlevels(grupos) > 1)\r\n      variables <- tab()$duration\r\n      dtf <- data.frame(Group = grupos, variables)\r\n      write.csv(dtf, file, row.names = TRUE)\r\n    }\r\n  )\r\n  \r\n  # --------------------------------------------------------------\r\n  # statistical report\r\n  observeEvent(input$report, {\r\n    shinybusy::show_modal_spinner(spin = \"fulfilling-square\",\r\n                                  color = \"#2e6da4\",\r\n                                  text = \"Finding the best-fitting models\")\r\n    grupos <- as.factor(mt()[, 1])\r\n    req(nlevels(grupos) > 1)\r\n    variables <- tab()$duration\r\n    dtf <- data.frame(Group = grupos, variables)\r\n    pval_adj <- ifelse(input$tukey == TRUE, \"tukey\", \"none\")\r\n    conf_lev <- input$conf1\r\n    progress <- shiny::Progress$new()\r\n    on.exit(progress$close())\r\n    nvar <- ncol(dtf)-1\r\n    gams_l <- lapply(2:ncol(dtf), function(i) {\r\n      out<- try(best_family_full(y = dtf[, i], Group = dtf$Group,\r\n                                 conf = conf_lev, adj = pval_adj))\r\n      progress$set(message = \"Fitting models...\", value = i/nvar,\r\n                   detail = paste(\"variable\", colnames(dtf)[i]))\r\n      out\r\n    })\r\n    names(gams_l) <- colnames(dtf[, -1])\r\n    fit_l <- lapply(gams_l, \"[[\", \"fit\")\r\n    means_l <- lapply(fit_l, function(x) {\r\n      try(emmeans::emmeans(x, specs = \"Group\", type = \"response\",\r\n                           level = gams_l[[1]]$conf),\r\n          silent = TRUE)\r\n    })\r\n    comp._l <- lapply(means_l, function(x) {\r\n      try(multcomp::cld(x, Letters = letters,\r\n                        adjust = pval_adj,\r\n                        level = conf_lev,\r\n                        alpha = 1-conf_lev),\r\n          silent=TRUE)\r\n    })\r\n    ff <- function(x) {\r\n      if(!inherits(x, \"try-error\")) {\r\n        x <- x[order(x$Group), ]\r\n        colnames(x)[2] <- \"emmean\"\r\n        m <- ifelse(x$emmean > 100, round(x$emmean), round(x$emmean, 2))\r\n        s <- ifelse(x$SE > 100, round(x$SE), round(x$SE, 2))\r\n        g <- gsub(\" \", \"\", x$\".group\")\r\n        out <- paste(m, \"±\", s, g)\r\n        names(out) <- paste0(\"Group_\", x$Group)\r\n      } else {\r\n        out <- rep(NA, nlevels(dtf$Group))\r\n      }\r\n      out\r\n    }\r\n    all_mc <- as.data.frame(t(sapply(comp._l, ff)))\r\n    comp_l <- lapply(means_l, function(x) {\r\n      try(pairs(x, adjust = pval_adj), \r\n          silent=TRUE)\r\n    })\r\n    ff2 <- function(x) {\r\n      if(!inherits(x, \"try-error\")) {\r\n        d <- data.frame(x)\r\n        w_test <- gsub(\".ratio\", \"\", colnames(d)[ncol(d)-1])\r\n        out <- d[, c(1, 2, 4, 4, ncol(d))]\r\n        out[, 4] <- w_test\r\n      } else {\r\n        out <- data.frame(NA, NA, NA, NA, NA)\r\n        w_test <- NA\r\n      }\r\n      rownames(out) <- NULL\r\n      colnames(out) <- c(\"contrast\", \"estimate/ratio\", \"df\", \"test\", \"p_value\")\r\n      out\r\n    }\r\n    comp_l2 <- lapply(comp_l, ff2)\r\n    all_mc2 <- do.call(rbind, comp_l2)\r\n    \r\n    shinybusy::remove_modal_spinner()\r\n    showNotification(\"DONE!\", duration = 2, type = \"message\")\r\n    \r\n    # output report\r\n    lrt_l <- lapply(gams_l, \"[[\", \"lrt\")\r\n    out_d <- data.frame(variable = names(gams_l), \r\n                        LRT = sapply(lrt_l, \"[[\", \"X2\"),\r\n                        Df = sapply(lrt_l, \"[[\", \"dfr\"),\r\n                        p_value = sapply(lrt_l, \"[[\", \"pvalue\"),\r\n                        distribution = sapply(lapply(gams_l, \"[[\", \"family\"), \"[\", 2),\r\n                        AIC = sapply(gams_l, \"[[\", \"aic\"),\r\n                        RMSE = sapply(gams_l, \"[[\", \"rmse\")\r\n    )\r\n    rownames(out_d) <- NULL\r\n    \r\n    output$downloadReport <- downloadHandler(\r\n      filename = \"infest_report.html\",\r\n      content = function(file) {\r\n        report_html <- tags$html(\r\n          tags$head(tags$title(\"INFEST Statistical Report\")),\r\n          tags$body(\r\n            h1(\"Statistical Analysis Report\"),\r\n            h2(\"Likelihood Ratio Tests for the 'Group' factor\"),\r\n            HTML(knitr::kable(out_d, format = \"html\")),\r\n            h2(\"Summary of multiple comparisons of means (± SE) of 'Group' levels\"),\r\n            HTML(knitr::kable(all_mc, format = \"html\")),\r\n            h2(\"Pairwise comparisons of means of 'Group' levels\"),\r\n            HTML(knitr::kable(all_mc2, format = \"html\")),\r\n            tags$footer(p(\"This document was automatically generated with INFEST - Insect Feeding Behavior Statistics v2.02\"),\r\n                        p(\"Date and time:\", Sys.time()))\r\n          )\r\n        )\r\n        writeLines(as.character(report_html), file)\r\n      }\r\n    )\r\n  })\r\n}\r\n\r\n\r\n# ----------------------------------------------------------------\r\nui = navbarPage(title = tags$head(img(src = \"https://github.com/arsilva87/infest/blob/5b234a69a2a96aa83323d17643c2d8fff98b128c/inst/infest/www/infest_2_0.png?raw=true\", height = 65), \r\n                                  \"Insect Feeding Behavior Statistics - light version\"),\r\n                windowTitle = \"INFEST 2.0 - Light\",\r\n                shinyjs::useShinyjs(),\r\n                div(style = \"margin-top:-20px\"),\r\n                # response variables  ------------------------------------------------------\r\n                tabPanel(\"Variables/Home\", icon = icon(\"bug\"),\r\n                         actionButton(\"hideSidebar\", \"Hide sidebar\",\r\n                                      style='padding:4px; font-size:80%;  background-color: lightyellow'),\r\n                         actionButton(\"showSidebar\", \"Show sidebar\",\r\n                                      style='padding:4px; font-size:80%;  background-color: lightgreen'),\r\n                         sidebarLayout(\r\n                           div( id =\"Sidebar\",\r\n                                sidebarPanel(width = 3,\r\n                                             fileInput(\"files\", \"Select one or more EPG files\", multiple = TRUE),\r\n                                             sliderInput(\"time_range\", \"Timeline trim (min.)\",\r\n                                                         min = 0, max = 7200, value = c(0, 7200)),\r\n                                             fluidRow(\r\n                                               column(3,\r\n                                                      tags$br(),\r\n                                                      actionButton(\"run\", \"Run\", icon = icon(\"r-project\"),\r\n                                                                   style=\"color: white; background-color: #2e6da4; border-color: white\")\r\n                                               )),\r\n                                             tags$small(\"Press F5/Refresh page to restart the app\")\r\n                                )\r\n                           ),\r\n                           mainPanel(width = 9,\r\n                                     h5(\"Response variables by insect\"),\r\n                                     tags$code(\"WARNING: only the column 'Group' should be edited!\"),\r\n                                     rhandsontable::rHandsontableOutput(\"duration\")\r\n                           )\r\n                         )\r\n                ),\r\n                # Report --------------------------------------------\r\n                tabPanel(\"Stats report\", icon = icon(\"person-running\"),\r\n                         #shinybusy::add_busy_spinner(spin = \"orbit\", position = \"bottom-right\"),\r\n                         h5(\"NO SWEAT!\"),\r\n                         h5(\"Find the best-fitting model for each response variable\r\n                            as a function of the factor 'Group', perform multiple comparisons of means,\r\n                            then download a statistical analysis report.\"),\r\n                         tags$br(),\r\n                         numericInput(\"conf1\", \"Confidence level\",\r\n                                      value = 0.95, min = 0, max = 1, step = 0.01),\r\n                         checkboxInput(\"tukey\", \"Tukey's p-value adjustment\", value = TRUE),\r\n                         tags$code(\"WARNING: this is a time-consuming task\"),\r\n                         tags$br(),\r\n                         actionButton(\"report\", \"Fit models\", icon = icon(\"r-project\"),\r\n                                      style=\"color: white; background-color: #2e6da4; border-color: white\"),\r\n                         downloadButton(\"downloadData\", \"Data\"),\r\n                         downloadButton(\"downloadReport\", \"Report\")\r\n                ),\r\n                tabPanel(\"About\", icon = icon(\"info-circle\"),\r\n                         tags$p(\"Discover the full version of INFEST and know more from: \",\r\n                                tags$a(\r\n                                  \"arsilva87.github.io/infest/\",\r\n                                  href = \"https://arsilva87.github.io/infest/\",\r\n                                  target = \"_blank\")\r\n                         )\r\n                )\r\n)\r\n\r\n# Run the app\r\n# runApp()   # to run locally\r\nshinyApp(ui = ui, server = server)\r\n\r\n\r\n","type":"text"},{"name":"app_infest_light.R","content":"\r\n# The INFEST app: insect feeding behavior statistics, the light version\r\n# shinylive::export(appdir = getwd(), destdir = \"docs\")\r\n# httpuv::runStaticServer(\"docs\")\r\n\r\nlibrary(shiny)\r\nlibrary(htmltools)\r\nlibrary(gamlss)\r\n\r\n# --------------------------------------------------\r\n# A function to process the insect feeding events from the EPG system\r\n\r\nepg <- function(filesIn, time_trim = NULL)\r\n{\r\n  files <- filesIn$name\r\n  nfiles <- length(files)\r\n  \r\n  # aux function for reading .ANA files\r\n  stylet_codes <- c(\"1\" = \"np\", \"2\" = \"C\", \"3\" = \"E1e\",\r\n                    \"4\" = \"E1\", \"5\" = \"E2\", \"6\" = \"F\",\r\n                    \"7\" = \"G\", \"8\" = \"pd\", \"9\" = \"II-2\",\r\n                    \"10\" = \"II-3\", \"11\" = \"w11\", \"12\" = \"w12\",\r\n                    \"99\" = \"T\")\r\n  read_ana <- function(f) {\r\n    d <- try(read.table(f, sep = \"\\t\", fileEncoding = \"UTF-16\"),\r\n             silent = TRUE)\r\n    if(inherits(d, \"try-error\")) d <- read.table(f, sep = \"\\t\",\r\n                                                 fileEncoding = \"UTF-8\")\r\n    d$V1 <- stylet_codes[as.character(d$V1)] # waveform\r\n    d$V2 <- as.double(gsub(\",\", \".\", d$V2))  # time\r\n    nr <- nrow(d)\r\n    dl <- lapply(1:nr, function(i) {\r\n      rbind(d$V1[i], d$V2[i])\r\n    })\r\n    unlist(dl)\r\n  }\r\n  \r\n  f_ext <- tools::file_ext( tolower(filesIn$datapath) )\r\n  ins  <- list()\r\n  for(i in 1:nfiles) {\r\n    ins[[i]] <- try(read_ana(filesIn$datapath[i]), silent = TRUE)\r\n    if(inherits(ins[[i]], \"try-error\")) {\r\n      ins[[i]] <- scan(filesIn$datapath[i],\r\n                       what = \"double\", sep = \",\", flush = TRUE, quiet = TRUE)\r\n      ins[[i]] <- gsub(\" \", \"\", ins[[i]], fixed = TRUE)\r\n    }\r\n    \r\n  }\r\n  names(ins) <- files\r\n  events <- sapply(ins, length)/2\r\n  \r\n  check <- (2*events) %% 2 != 0  # is odd = maybe missing lines\r\n  o <- which(check == TRUE)\r\n  if (any(check == TRUE)) {\r\n    ins[o] <- NULL\r\n    showNotification(paste(\" Error (please check line labels) in file(s):\",\r\n                           paste(files[o], collapse = \", \")),\r\n                     type = \"error\", duration = 10)\r\n  }\r\n  \r\n  fcheck2 <- function(x) {\r\n    aux <- seq.int(1, length(x), by = 1)\r\n    w <- x[aux %% 2 != 0]\r\n    n <- length(w)\r\n    any(w[-n] == w[-1])\r\n  }\r\n  check2 <- sapply(ins, fcheck2)\r\n  o2 <- which(check2 == TRUE)\r\n  if (any(check2 == TRUE)) {\r\n    showNotification(paste(\"The following file(s) seem(s) to have labels consecutively repeated :\",\r\n                           paste(files[o2], collapse = \", \")),\r\n                     type = \"warning\", duration = 10)\r\n  }\r\n  \r\n  # time trim (optional)\r\n  if(!is.null(time_trim)) {\r\n    ins <- lapply(ins, function(x) {\r\n      time_rec <- as.double(x)\r\n      o <- which(time_rec >= time_trim[1] & time_rec <= time_trim[2])\r\n      if(length(o) < 2) {\r\n        showNotification(\" Time interval is too short! \",\r\n                         type = \"error\", duration = 5)\r\n      }\r\n      w <- seq.int(min(o)-1, max(o), by = 1)\r\n      x[w]\r\n    })\r\n  }\r\n  \r\n  # aux function to get odd indexes from elements of ins list\r\n  fodd <- function(x) {\r\n    n <- length(x)\r\n    aux <- seq.int(1, n, by = 1)\r\n    y <- x[aux %% 2 != 0]\r\n    y\r\n  }\r\n  waves <- lapply(ins, fodd)\r\n  levels <- lapply(waves, unique)\r\n  lev <- unique(unlist(levels))\r\n  waves <- lapply(waves, factor, levels = lev)\r\n  table_func <- function(x) {\r\n    out <- table(x)\r\n    names(out) <- paste0(\"NWEi_\", names(out))\r\n    out\r\n  }\r\n  waveevents <- t(sapply(waves, table_func))   # output and export csv\r\n  \r\n  # aux function to compute the seq variables\r\n  countseq <- function(x) {\r\n    n <- length(x)\r\n    tabpair <- table(x[-n], x[-1], dnn = list(\"from\", \"to\"))\r\n    diag(tabpair) <- NA\r\n    dfpair <- data.frame(tabpair)\r\n    dfpair <- subset(dfpair, from != to)\r\n    pares <- paste0(dfpair$from, \"-\", dfpair$to)\r\n    count <- dfpair$Freq\r\n    names(count) <- pares\r\n    count\r\n  }\r\n  seqevents <- t(sapply(waves, countseq))   # output and export csv\r\n  \r\n  # get the sequential events as a 2-way table count for network graph\r\n  tableseq <- function(x) {\r\n    n <- length(x)\r\n    tabseq <- table(x[-n], x[-1], dnn = c(\"from\", \"to\"))\r\n    diag(tabseq) <- table(x)\r\n    tabseq\r\n  }\r\n  tabseq <- lapply(waves, tableseq)\r\n  sumtabseq <- Reduce(\"+\", tabseq)\r\n  \r\n  # transition matrix\r\n  countseq_m <- function(x) {\r\n    n <- length(x)\r\n    tabpair <- table(x[-n], x[-1], dnn = list(\"from\", \"to\"))\r\n    tabpair\r\n  }\r\n  tran_mats <- lapply(waves, countseq_m)\r\n  tran_mat <- Reduce(\"+\", tran_mats)\r\n  \r\n  # DURATION - aux funct using even and odd indexes at each element of the list\r\n  #nonprobe <- c(\"Z\", \"z\", \"np\", \"NP\", \"nP\", \"Np\")\r\n  w_nonprobe <- regexpr(c(\"np\", \"z\"), lev, ignore.case = TRUE) > 0\r\n  nonprobe <- lev[w_nonprobe]\r\n  probe_waves <- lev[!(lev %in% nonprobe)]\r\n  \r\n  evenodd <- function(x, arq) {\r\n    n <- length(x)\r\n    aux <- seq.int(1, n, by = 1)\r\n    waves <- factor(x[aux %% 2 != 0], levels = lev)\r\n    cumtimes <- as.numeric(x[aux %% 2 == 0])\r\n    if(arq == \"ana\") {\r\n      times <- diff(cumtimes)\r\n      n2 <- n/2\r\n      out <- tapply(times, waves[-n2], FUN = sum)\r\n    } else {\r\n      times <- c(cumtimes[1], diff(cumtimes))\r\n      out <- tapply(times, waves, FUN = sum)\r\n    }\r\n    names(out) <- paste0(\"WDi_\", names(out))\r\n    out\r\n  }\r\n  times <- t(sapply(ins, evenodd, arq = f_ext[1]))\r\n  times[is.na(times)] <- 0\r\n  \r\n  # duration per event\r\n  de <- times/waveevents\r\n  de[is.na(de)] <- 0\r\n  if(nrow(de) > 1 | !is.null(dim(de))) {\r\n    colnames(de) <- gsub(\"WDi\", \"WDEi\", colnames(de))\r\n  } else {\r\n    names(de) <- gsub(\"WDi\", \"WDEi\", names(de))\r\n  }\r\n  \r\n  # duration of first or second event 'W'\r\n  DurFS_func <- function(x, pos, arq) {\r\n    n <- length(x)\r\n    aux <- seq.int(1, n, by = 1)\r\n    waves <- factor(x[aux %% 2 != 0], levels = lev)\r\n    cumtimes <- as.numeric(x[aux %% 2 == 0])\r\n    if(arq == \"ana\") {\r\n      times <- diff(cumtimes)\r\n    } else {\r\n      times <- c(cumtimes[1], diff(cumtimes))\r\n    }\r\n    DurFSW <- sapply(lev, function(w) {\r\n      o <- which(waves %in% w)[pos]\r\n      times[o]\r\n    })\r\n    names(DurFSW) <- paste0(\"DurFrs_\", names(DurFSW))\r\n    DurFSW\r\n  }\r\n  DurFrsW <- t(sapply(ins, DurFS_func, pos = 1, arq = f_ext[1]))\r\n  DurFrsW[is.na(DurFrsW)] <- 0\r\n  \r\n  # number of events to first event W\r\n  NumEvFrsW_fun <- function(x) {\r\n    out <- sapply(probe_waves, function(w) {\r\n      r <- which(w == x)[1] - 1\r\n      names(r) <- paste0(\"NumEvFrs_\", w)\r\n      r\r\n    }, USE.NAMES = FALSE)\r\n    out\r\n  }\r\n  NumEvFrsW <- t(sapply(waves, NumEvFrsW_fun))\r\n  \r\n  final_data <- data.frame(times,\r\n                           waveevents,\r\n                           de,\r\n                           DurFrsW,\r\n                           NumEvFrsW)\r\n  # output\r\n  out <- list(duration = final_data,\r\n              seqevents = seqevents,\r\n              tabseqevents = sumtabseq,\r\n              transmatrix = tran_mat)\r\n  return(out)\r\n}\r\n\r\n# ----------------------------------------------------------\r\n# aux function\r\n\r\nf_rmse <<- function(model) {\r\n  res = model[[\"y\"]] - fitted(model)\r\n  sqrt(mean(res^2))\r\n}\r\n\r\nzerofams <<- c(\"NO\", \"PARETO2\", \"ZAGA\", \"ZAIG\",\r\n               \"PO\", \"NBII\", \"ZIP\", \"ZINBI\", \"PIG\")\r\n\r\n# ----------------------------------------------------------\r\n# aux function to automatically fit all models and gen. report\r\n\r\nlrt_func <- function(mod) {\r\n  l <- logLik(mod)\r\n  mod0 <- update(mod, formula = ~1, sigma.formula = ~1,\r\n                 family = mod$family[1])\r\n  l0 <- logLik(mod0)\r\n  X2 <- 2*c(l - l0)\r\n  grau <- attr(l, \"df\") - attr(l0, \"df\")\r\n  pval <- pchisq(X2, grau, lower = F)\r\n  if(inherits(mod, \"try-error\")) {\r\n    out <- list(X2 = NA, dfr = NA, pvalue = NA)\r\n  } else {\r\n    out <- list(X2 = X2, dfr = grau, pvalue = pval)\r\n  }\r\n  class(out) <- \"lrt_func\"\r\n  out\r\n}\r\n\r\nbest_family_full <- function(y, Group, conf = 0.95, adj = \"none\") {\r\n  fams <- c(\"NO\", \"EXP\", \"GA\", \"IGAMMA\", \"IG\",\r\n            \"WEI\", \"PARETO2\", \"ZAGA\", \"ZAIG\",\r\n            \"PO\", \"NBII\", \"ZIP\", \"ZINBI\", \"PIG\")\r\n  m1 <- m2 <- list()\r\n  nf <- length(fams)\r\n  d <- data.frame(y = y, Group = Group)\r\n  d <- d[complete.cases(d), ]\r\n  assign(\"ddd\", d, envir = .GlobalEnv)\r\n  for(i in 1:nf) {\r\n    dat <- get(\"ddd\", envir = .GlobalEnv)\r\n    m1[[i]] <- try(gamlss(dat$y ~ dat$Group, sigma.formula = ~1,\r\n                          family = fams[i],\r\n                          #data = get(\"ddd\", envir = .GlobalEnv),\r\n                          trace=FALSE),\r\n                   silent = TRUE)\r\n    m2[[i]] <- try(gamlss(dat$y ~ dat$Group, sigma.formula = ~Group,\r\n                          family = fams[i],\r\n                          #data = get(\"ddd\", envir = .GlobalEnv),\r\n                          trace=FALSE),\r\n                   silent = TRUE)\r\n  }\r\n  gams <- c(m1, m2)\r\n  aics <- sapply(gams, function(w) {\r\n    ifelse(inherits(w, \"try-error\"), NA, AIC(w))\r\n  })\r\n  o_aic <- which.min(aics)\r\n  if(length(o_aic) == 0) o_aic = 1\r\n  mod <- gams[[o_aic]]\r\n  if(!inherits(mod, \"try-error\")) {\r\n    mod$family <- gams[[o_aic]]$family\r\n    mod$call[4] <- mod$family[1]\r\n    lrt <- lrt_func(mod)\r\n    dfr <- mod$df.residual\r\n    aic <- mod$aic\r\n    rmse <- f_rmse(mod)\r\n  } else {\r\n    mod$family <- c(NA, NA)\r\n    mod$call[4] <- NA\r\n    lrt <- list(X2 = NA, dfr = NA, pvalue = NA)\r\n    dfr <- NA\r\n    aic <- NA\r\n    rmse <- NA\r\n  }\r\n  out <- list(dtf = d,\r\n              fit = mod,\r\n              lrt = lrt,\r\n              conf = conf,\r\n              adj = adj,\r\n              dfr = dfr,\r\n              family = mod$family,\r\n              aic = aic,\r\n              rmse = rmse)\r\n  class(out) <- \"infest\"\r\n  return(out)\r\n}\r\n\r\n\r\n# server ---------------------------------------------------\r\nserver <- function(input, output, session){\r\n  filesIn <- reactive({\r\n    validate(\r\n      need(input$files != \"\", \"...waiting for the input files\")\r\n    )\r\n    input$files\r\n  })\r\n  \r\n  observeEvent(input$showSidebar, {\r\n    shinyjs::show(id = \"Sidebar\")\r\n  })\r\n  observeEvent(input$hideSidebar, {\r\n    shinyjs::hide(id = \"Sidebar\")\r\n  })\r\n  \r\n  tab <- eventReactive(input$run, {\r\n    epg(filesIn(), time_trim = input$time_range * 60)\r\n  })\r\n  \r\n  # ------------------------------------- duration\r\n  dur <- reactive({\r\n    df <- tab()$duration\r\n    n <- nrow(df)\r\n    df <- data.frame(Group = as.integer(rep(1, n)), round(df, 2))\r\n    df\r\n  })\r\n  \r\n  output$duration <- rhandsontable::renderRHandsontable({\r\n    df_den <- data.frame(Group = dur()[, 1], dur()[, -1])\r\n    updateSelectInput(session, inputId = 'y', choices = names(df_den)[-1])\r\n    rhandsontable::rhandsontable(df_den, rowHeaderWidth=180)\r\n  })\r\n  mt <- reactive({\r\n    DF = rhandsontable::hot_to_r(input$duration)\r\n    if(!is.null(input$tab$changes$changes)) {\r\n      row.no <- unlist(input$tab$changes$changes)[1]\r\n      col.no <- unlist(input$tab$changes$changes)[2]\r\n      new.val <- unlist(input$tab$changes$changes)[4]\r\n    }\r\n    DF\r\n  })\r\n  \r\n  output$downloadData <- downloadHandler(\r\n    filename = function() {\r\n      \"infest_data.csv\"\r\n    },\r\n    content = function(file) {\r\n      grupos <- as.factor(mt()[, 1])\r\n      req(nlevels(grupos) > 1)\r\n      variables <- tab()$duration\r\n      dtf <- data.frame(Group = grupos, variables)\r\n      write.csv(dtf, file, row.names = TRUE)\r\n    }\r\n  )\r\n  \r\n  # --------------------------------------------------------------\r\n  # statistical report\r\n  observeEvent(input$report, {\r\n    shinybusy::show_modal_spinner(spin = \"fulfilling-square\",\r\n                                  color = \"#2e6da4\",\r\n                                  text = \"Finding the best-fitting models\")\r\n    grupos <- as.factor(mt()[, 1])\r\n    req(nlevels(grupos) > 1)\r\n    variables <- tab()$duration\r\n    dtf <- data.frame(Group = grupos, variables)\r\n    pval_adj <- ifelse(input$tukey == TRUE, \"tukey\", \"none\")\r\n    conf_lev <- input$conf1\r\n    progress <- shiny::Progress$new()\r\n    on.exit(progress$close())\r\n    nvar <- ncol(dtf)-1\r\n    gams_l <- lapply(2:ncol(dtf), function(i) {\r\n      out<- try(best_family_full(y = dtf[, i], Group = dtf$Group,\r\n                                 conf = conf_lev, adj = pval_adj))\r\n      progress$set(message = \"Fitting models...\", value = i/nvar,\r\n                   detail = paste(\"variable\", colnames(dtf)[i]))\r\n      out\r\n    })\r\n    names(gams_l) <- colnames(dtf[, -1])\r\n    fit_l <- lapply(gams_l, \"[[\", \"fit\")\r\n    means_l <- lapply(fit_l, function(x) {\r\n      try(emmeans::emmeans(x, specs = \"Group\", type = \"response\",\r\n                           level = gams_l[[1]]$conf),\r\n          silent = TRUE)\r\n    })\r\n    comp._l <- lapply(means_l, function(x) {\r\n      try(multcomp::cld(x, Letters = letters,\r\n                        adjust = pval_adj,\r\n                        level = conf_lev,\r\n                        alpha = 1-conf_lev),\r\n          silent=TRUE)\r\n    })\r\n    ff <- function(x) {\r\n      if(!inherits(x, \"try-error\")) {\r\n        x <- x[order(x$Group), ]\r\n        colnames(x)[2] <- \"emmean\"\r\n        m <- ifelse(x$emmean > 100, round(x$emmean), round(x$emmean, 2))\r\n        s <- ifelse(x$SE > 100, round(x$SE), round(x$SE, 2))\r\n        g <- gsub(\" \", \"\", x$\".group\")\r\n        out <- paste(m, \"±\", s, g)\r\n        names(out) <- paste0(\"Group_\", x$Group)\r\n      } else {\r\n        out <- rep(NA, nlevels(dtf$Group))\r\n      }\r\n      out\r\n    }\r\n    all_mc <- as.data.frame(t(sapply(comp._l, ff)))\r\n    comp_l <- lapply(means_l, function(x) {\r\n      try(pairs(x, adjust = pval_adj), \r\n          silent=TRUE)\r\n    })\r\n    ff2 <- function(x) {\r\n      if(!inherits(x, \"try-error\")) {\r\n        d <- data.frame(x)\r\n        w_test <- gsub(\".ratio\", \"\", colnames(d)[ncol(d)-1])\r\n        out <- d[, c(1, 2, 4, 4, ncol(d))]\r\n        out[, 4] <- w_test\r\n      } else {\r\n        out <- data.frame(NA, NA, NA, NA, NA)\r\n        w_test <- NA\r\n      }\r\n      rownames(out) <- NULL\r\n      colnames(out) <- c(\"contrast\", \"estimate/ratio\", \"df\", \"test\", \"p_value\")\r\n      out\r\n    }\r\n    comp_l2 <- lapply(comp_l, ff2)\r\n    all_mc2 <- do.call(rbind, comp_l2)\r\n    \r\n    shinybusy::remove_modal_spinner()\r\n    showNotification(\"DONE!\", duration = 2, type = \"message\")\r\n    \r\n    # output report\r\n    lrt_l <- lapply(gams_l, \"[[\", \"lrt\")\r\n    out_d <- data.frame(variable = names(gams_l), \r\n                        LRT = sapply(lrt_l, \"[[\", \"X2\"),\r\n                        Df = sapply(lrt_l, \"[[\", \"dfr\"),\r\n                        p_value = sapply(lrt_l, \"[[\", \"pvalue\"),\r\n                        distribution = sapply(lapply(gams_l, \"[[\", \"family\"), \"[\", 2),\r\n                        AIC = sapply(gams_l, \"[[\", \"aic\"),\r\n                        RMSE = sapply(gams_l, \"[[\", \"rmse\")\r\n    )\r\n    rownames(out_d) <- NULL\r\n    \r\n    output$downloadReport <- downloadHandler(\r\n      filename = \"infest_report.html\",\r\n      content = function(file) {\r\n        report_html <- tags$html(\r\n          tags$head(tags$title(\"INFEST Statistical Report\")),\r\n          tags$body(\r\n            h1(\"Statistical Analysis Report\"),\r\n            h2(\"Likelihood Ratio Tests for the 'Group' factor\"),\r\n            HTML(knitr::kable(out_d, format = \"html\")),\r\n            h2(\"Summary of multiple comparisons of means (± SE) of 'Group' levels\"),\r\n            HTML(knitr::kable(all_mc, format = \"html\")),\r\n            h2(\"Pairwise comparisons of means of 'Group' levels\"),\r\n            HTML(knitr::kable(all_mc2, format = \"html\")),\r\n            tags$footer(p(\"This document was automatically generated with INFEST - Insect Feeding Behavior Statistics v2.02\"),\r\n                        p(\"Date and time:\", Sys.time()))\r\n          )\r\n        )\r\n        writeLines(as.character(report_html), file)\r\n      }\r\n    )\r\n  })\r\n}\r\n\r\n\r\n# ----------------------------------------------------------------\r\nui = navbarPage(title = tags$head(img(src = \"https://github.com/arsilva87/infest/blob/5b234a69a2a96aa83323d17643c2d8fff98b128c/inst/infest/www/infest_2_0.png?raw=true\", height = 65), \r\n                                  \"Insect Feeding Behavior Statistics - light version\"),\r\n                windowTitle = \"INFEST 2.0 - Light\",\r\n                shinyjs::useShinyjs(),\r\n                div(style = \"margin-top:-20px\"),\r\n                # response variables  ------------------------------------------------------\r\n                tabPanel(\"Variables/Home\", icon = icon(\"bug\"),\r\n                         actionButton(\"hideSidebar\", \"Hide sidebar\",\r\n                                      style='padding:4px; font-size:80%;  background-color: lightyellow'),\r\n                         actionButton(\"showSidebar\", \"Show sidebar\",\r\n                                      style='padding:4px; font-size:80%;  background-color: lightgreen'),\r\n                         sidebarLayout(\r\n                           div( id =\"Sidebar\",\r\n                                sidebarPanel(width = 3,\r\n                                             fileInput(\"files\", \"Select one or more EPG files\", multiple = TRUE),\r\n                                             sliderInput(\"time_range\", \"Timeline trim (min.)\",\r\n                                                         min = 0, max = 7200, value = c(0, 7200)),\r\n                                             fluidRow(\r\n                                               column(3,\r\n                                                      tags$br(),\r\n                                                      actionButton(\"run\", \"Run\", icon = icon(\"r-project\"),\r\n                                                                   style=\"color: white; background-color: #2e6da4; border-color: white\")\r\n                                               )),\r\n                                             tags$small(\"Press F5/Refresh page to restart the app\")\r\n                                )\r\n                           ),\r\n                           mainPanel(width = 9,\r\n                                     h5(\"Response variables by insect\"),\r\n                                     tags$code(\"WARNING: only the column 'Group' should be edited!\"),\r\n                                     rhandsontable::rHandsontableOutput(\"duration\")\r\n                           )\r\n                         )\r\n                ),\r\n                # Report --------------------------------------------\r\n                tabPanel(\"Stats report\", icon = icon(\"person-running\"),\r\n                         #shinybusy::add_busy_spinner(spin = \"orbit\", position = \"bottom-right\"),\r\n                         h5(\"NO SWEAT!\"),\r\n                         h5(\"Find the best-fitting model for each response variable\r\n                            as a function of the factor 'Group', perform multiple comparisons of means,\r\n                            then download a statistical analysis report.\"),\r\n                         tags$br(),\r\n                         numericInput(\"conf1\", \"Confidence level\",\r\n                                      value = 0.95, min = 0, max = 1, step = 0.01),\r\n                         checkboxInput(\"tukey\", \"Tukey's p-value adjustment\", value = TRUE),\r\n                         tags$code(\"WARNING: this is a time-consuming task\"),\r\n                         tags$br(),\r\n                         actionButton(\"report\", \"Fit models\", icon = icon(\"r-project\"),\r\n                                      style=\"color: white; background-color: #2e6da4; border-color: white\"),\r\n                         downloadButton(\"downloadData\", \"Data\"),\r\n                         downloadButton(\"downloadReport\", \"Report\")\r\n                ),\r\n                tabPanel(\"About\", icon = icon(\"info-circle\"),\r\n                         tags$p(\"Discover the full version of INFEST and know more from: \",\r\n                                tags$a(\r\n                                  \"arsilva87.github.io/infest/\",\r\n                                  href = \"https://arsilva87.github.io/infest/\",\r\n                                  target = \"_blank\")\r\n                         )\r\n                )\r\n)\r\n\r\n# Run the app\r\n# runApp()   # to run locally\r\nshinyApp(ui = ui, server = server)\r\n\r\n\r\n","type":"text"}]
